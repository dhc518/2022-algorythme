근사 알고리즘

위 문제들은 다항식 시간에 해결할 수 있는 알고리즘이 아직 발견되지 않았다.

해결 방법
1 다항식 시간에 해를 찾는것
2. 모든 입력에 대해 해를 찾는 것
3. 최적해를 찾는 것

근사 알고리즘은 3번을 포기한다.

근사해를 찾는 대신에 다항식 시간의 복잡도를 가진다
근사 비율은 근사해의 값과 최적해의 값의 비율로서 1.0에 가까울수록 정확도가 높은 알고리즘
근사비율을 계산하려면 최적해를 알아야하는 모순 발생
간접적인 최적해를 찾고 이를 최적해로 삼아서 근사 비율을 계산

여행자 문제를 위한 근사 알고리즘은 최소 신장트리의 모든 점을 연결하는 특성과 최소 가중치의 특성을 이용한다. 근사비율은 2.0

통채우기 문제는 모두 2.0 다음 해가 시간 복잡도가 적다.

8.1 여행자 문제
여행자가 임의의 한 됫에서 출발하여 다른 모든 도시를 1번씩만 방문하고 다시 출발핶던 도시로 돌아오는 여행 경로의 길이를 최소화하는 문제
도시 가 에서 도시 나 로 가는 거히는 도시 나에서 도시 가로 가는 거리와 같다(대칭성)
도시 가에서 도시 나로 가는 거리는 도시 가에서 다른 도시 다를 경우하여 도시 나로 가는 거리 보다 짧다.(삼각부등식 특성)

mst로 푼다

8.2 정점 커버문제
극대 매칭
매칭이란 각 전선의 양똑 끝점들이 중복되지 않는 간선의 집합


8.3 통 채우기 문제
그리디 아이지더
최초 적합
다음 적합
최선 적합
최악 적합

8.4 작업 스케줄링 문제
8.5 클러스터링 문제
approx_k_clusters

C[1] = r
for j = 2 to k
	fori = 0 to n-1
		if xi != 센터
			
O(k^2*n)
근사비율 2.0
첫 센터를 랜검하게 선택하므로 보다 나은 클러스터링을 위해 알고리즘을 여러 차례 수행하여 얻은 결과 중에 최선 클러스터링을 사용한다

python -m pip install C:\Users\Administrator\Downloads\pygame-2.1.2-cp311-cp311-win_amd64.whl